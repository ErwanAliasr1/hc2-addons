{"name":"AudioStation","type":"virtual_device","properties":{"deviceIcon":7,"currentIcon":"7","log":"","logTemp":"","mainLoop":"-- Copyright Erwan Velu 2015\n-- This code is under GPL\n--\n--\n-- Dependencies: Toolkit Framework (built-in)\n\n-- Items to be adjusted\nlocal user = \"admin\"\nlocal password = \"dsm42support\"\nlocal player_name = \"Yamaha-TV (Airplay)\"\nlocal ip = \"192.168.1.2\"\nlocal port = \"5000\"\nlocal default_volume = 27\n-- Don't touch that unless requested\nlocal base_url = \"http://\" .. ip .. \":\" .. port .. \"/\"\nlocal player_id = nil\nlocal sid = nil\nlocal commandTimeOut = 3500\nlocal debug = false\nlocal version = \"1.0\"\nlocal release = \"rc1\"\nlocal session_url = \"&session=AudioStation\"\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\n-- Toolkit Framework, lua library extention for HC2, hope that it will be useful.\n-- This Framework is an addon for HC2 Toolkit application in a goal to aid the integration.\n-- Tested on Lua 5.1 with Fibaro HC2 3.572 beta\n--\n-- Version 1.0.4 [01-13-2014]\n--\n-- Use: Toolkit or Tk shortcut to access Toolkit namespace members.\n--\n-- Example:\n-- Toolkit:trace(\"value is %d\", 35); or Tk:trace(\"value is %d\", 35);\n-- Toolkit.assertArg(\"argument\", arg, \"string\"); or Tk.assertArg(\"argument\", arg, \"string\");\n--\n-- current release: http://krikroff77.github.io/Fibaro-HC2-Toolkit-Framework/\n-- latest release: https://github.com/Krikroff77/Fibaro-HC2-Toolkit-Framework/releases/latest\n--\n-- Memory is preserved: The code is loaded only the first time in a virtual device \n-- main loop and reloaded only if application pool restarded.\n--\n-- Copyright (C) 2013-2014 Jean-Christophe Vermandé\n-- \n-- This program is free software: you can redistribute it and/or modify\n-- it under the terms of the GNU General Public License as published by\n-- the Free Software Foundation, either version 3 of the License, or\n-- at your option) any later version.\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\nif not Toolkit then Toolkit = { \n\t__header = \"Toolkit\",\n\t__version = \"1.0.4\",\n\t__luaBase = \"5.1.0\", \n\t__copyright = \"Jean-Christophe Vermandé\",\n\t__licence = [[\n\tCopyright (C) 2013-2014 Jean-Christophe Vermandé\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses></http:>.\n\t]],\n\t__frameworkHeader = (function(self)\n\t\tself:traceEx(\"green\", \"-------------------------------------------------------------------------\");\n\t\tself:traceEx(\"green\", \"-- HC2 Toolkit Framework version %s\", self.__version);\n\t\tself:traceEx(\"green\", \"-- Current interpreter version is %s\", self.getInterpreterVersion());\n\t\tself:traceEx(\"green\", \"-- Total memory in use by Lua: %.2f Kbytes\", self.getCurrentMemoryUsed());\n\t\tself:traceEx(\"green\", \"-------------------------------------------------------------------------\");\n\tend),\n\t-- chars\n\tchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n\t-- hex\n\thex = \"0123456789abcdef\",\n\t-- now(), now(\"*t\", 906000490)\n\t-- system date shortcut\n\tnow = os.date,\n\t-- toUnixTimestamp(t)\n\t-- t (table)\t\t- {year=2013, month=12, day=20, hour=12, min=00, sec=00}\n\t-- return Unix timestamp\n\ttoUnixTimestamp = (function(t) return os.time(t) end),\n\t-- fromUnixTimestamp(ts)\n\t-- ts (string/integer)\t- the timestamp\n\t-- Example : fromUnixTimestamp(1297694343) -> 02/14/11 15:39:03\n\tfromUnixTimestamp = (function(s) return os.date(\"%c\", ts) end),\n\t-- currentTime()\n\t-- return current time\n\tcurrentTime = (function() return tonumber(os.date(\"%H%M%S\")) end),\n\t-- comparableTime(hour, min, sec)\n\t-- hour (string/integer)\n\t-- min (string/integer)\n\t-- sec (string/integer)\n\tcomparableTime = (function(hour, min, sec) return tonumber(string.format(\"%02d%02d%02d\", hour, min, sec)) end),\n\t-- isTraceEnabled\n\t-- (boolean)\tget or set to enable or disable trace\n\tisTraceEnabled = true,\n\t-- isAutostartTrigger()\n\tisAutostartTrigger = (function() local t = fibaro:getSourceTrigger();return (t[\"type\"]==\"autostart\") end),\n\t-- isOtherTrigger()\n\tisOtherTrigger = (function() local t = fibaro:getSourceTrigger();return (t[\"type\"]==\"other\") end),\n\t-- raiseError(message, level)\n\t-- message (string)\t- message\n\t-- level (integer)\t- level\n\traiseError = (function(message, level) error(message, level); end),\n\t-- colorSetToRgbwTable(colorSet)\n\t-- colorSet (string) - colorSet string\n\t-- Example: local r, g, b, w = colorSetToRgbwTable(fibaro:getValue(354, \"lastColorSet\"));\n\tcolorSetToRgbw = (function(self, colorSet)\n\t\tself.assertArg(\"colorSet\", colorSet, \"string\");\n\t\tlocal t, i = {}, 1;\n\t\tfor v in string.gmatch(colorSet,\"(%d+)\") do t[i] = v; i = i + 1; end\n\t\treturn t[1], t[2], t[3], t[4];\n\tend),\n\t-- isValidJson(data, raise)\n\t-- data (string)\t- data\n\t-- raise (boolean)- true if must raise error\n\t-- check if json data is valid\n\tisValidJson = (function(self, data, raise)\n\t\tself.assertArg(\"data\", data, \"string\");\n\t\tself.assertArg(\"raise\", raise, \"boolean\");\n\t\tif (string.len(data)>0) then\n\t\t\tif (pcall(function () return json.decode(data) end)) then\n\t\t\treturn true;\n\t\telse\n\t\t\tif (raise) then self.raiseError(\"invalid json\", 2) end;\n\t\tend\n\tend\n\treturn false;\nend),\n-- assert_arg(name, value, typeOf)\n-- (string)\tname: name of argument\n-- (various)\tvalue: value to check\n-- (type)\t\ttypeOf: type used to check argument\nassertArg = (function(name, value, typeOf)\n\tif type(value) ~= typeOf then\n\t\tTk.raiseError(\"argument \"..name..\" must be \"..typeOf, 2);\n\tend\nend),\n-- trace(value, args...)\n-- (string)\tvalue: value to trace (can be a string template if args)\n-- (various)\targs: data used with template (in value parameter)\ntrace = (function(self, value, ...)\n\tif (self.isTraceEnabled) then\n\t\tif (value~=nil) then        \n\t\t\treturn fibaro:debug(string.format(value, ...));\n\t\tend\n\tend\nend),\n-- traceEx(value, args...)\n-- (string)\tcolor: color use to display the message (red, green, yellow)\n-- (string)\tvalue: value to trace (can be a string template if args)\n-- (various)\targs: data used with template (in value parameter)\ntraceEx = (function(self, color, value, ...)\n\tself:trace(string.format('<%s style=\"color:%s;\">%s</%s>', \"span\", color, string.format(value, ...), \"span\"));\nend),\n-- getInterpreterVersion()\n-- return current lua interpreter version\ngetInterpreterVersion = (function()\n\treturn _VERSION;\nend),\n-- getCurrentMemoryUsed()\n-- return total current memory in use by lua interpreter\ngetCurrentMemoryUsed = (function()\n\treturn collectgarbage(\"count\");\nend),\n-- trim(value)\n-- (string)\tvalue: the string to trim\ntrim = (function(s)\n\tTk.assertArg(\"value\", s, \"string\");\n\treturn (string.gsub(s, \"^%s*(.-)%s*$\", \"%1\"));\nend),\n-- isNaN(value)\n-- return true is NaN or false if not NaN\nisNaN = (function (x) return x ~= x end),\n-- filterByPredicate(table, predicate)\n-- table (table)\t\t- table to filter\n-- predicate (function)\t- function for predicate\n-- Description: filter a table using a predicate\n-- Usage:\n-- local t = {1,2,3,4,5};\n-- local out, n = filterByPredicate(t,function(v) return v.item == true end);\n-- return out -> {2,4}, n -> 2;\nfilterByPredicate = (function(table, predicate)\n\tTk.assertArg(\"table\", table, \"table\");\n\tTk.assertArg(\"predicate\", predicate, \"function\");\n\tlocal n, out = 1, {};\n\tfor i = 1,#table do\n\t\tlocal v = table[i];\n\t\tif (v~=nil) then\n\t\t\tif predicate(v) then\n\t\t\t\tout[n] = v;\n\t\t\t\tn = n + 1;    \n\t\t\tend\n\t\tend\n\tend\n\treturn out, #out;\nend)\n};Toolkit:__frameworkHeader();Tk=Toolkit;\nend;\n\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\n-- Toolkit.Net library extention\n-- Toolkit.Net.HttpRequest provide http request with advanced functions\n-- Tested on Lua 5.1 with HC2 3.572 beta\n--\n-- Copyright 2013 Jean-christophe Vermandé\n-- Thanks to rafal.m for the decodeChunks function used when reponse body is \"chunked\"\n-- http://en.wikipedia.org/wiki/Chunked_transfer_encoding\n--\n-- Version 1.0.3 [12-13-2013]\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\nif not Toolkit then error(\"You must add Toolkit\", 2) end\nif not Toolkit.Net then Toolkit.Net = {\n\t-- private properties\n\t__header = \"Toolkit.Net\",\n\t__version = \"1.0.3\",\n\t__cr = string.char(13),\n\t__lf = string.char(10),\n\t__crLf = string.char(13, 10),\n\t__host = nil,\n\t__port = nil,\n\t-- private methods\n\t__trace = (function(v, ...)\n\t\tif (Toolkit.Net.isTraceEnabled) then Toolkit:trace(v, ...) end\n\tend),\n\t__writeHeader = (function(socket, data)\n\t\tassert(tostring(data) or data==nil or data==\"\", \"Invalid header found: \"..data);\n\t\tlocal head = tostring(data);\n\t\tsocket:write(head..Toolkit.Net.__crLf);\n\t\tToolkit.Net.__trace(\"%s.%s::request > Add header [%s]\", \n\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, head);\n\tend),\n\t__decodeChunks = (function(a)\n\t\tresp = \"\";\n\t\tline = \"0\";\n\t\tlenline = 0;\n\t\tlen = string.len(a);\n\t\ti = 1;\n\t\twhile i<=len do\n\t\t\tc = string.sub(a, i, i);\n\t\t\tif (lenline==0) then\n\t\t\t\tif (c==Toolkit.Net.__lf) then\n\t\t\t\t\tlenline = tonumber(line, 16);\n\t\t\t\t\tif (lenline==null) then\n\t\t\t\t\t\tlenline = 0;\n\t\t\t\t\tend\n\t\t\t\t\tline = 0;\n\t\t\t\telseif (c==Toolkit.Net.__cr) then\n\t\t\t\t\tlenline = 0;\n\t\t\t\telse\n\t\t\t\t\tline = line .. c;\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tresp = resp .. c;\n\t\t\t\tlenline = lenline - 1;\n\t\t\tend\n\t\t\ti = i + 1;\n\t\tend\n\t\treturn resp;\n\tend),\n\t__readHeader = (function(data)\n\t\tif data == nil then\n\t\t\terror(\"Couldn't find header\");\n\t\tend\n\t\tlocal buffer = \"\";\n\t\tlocal headers = {};\n\t\tlocal i, len = 1, string.len(data);\n\t\twhile i<=len do\n\t\t\tlocal a = data:sub(i,i) or \"\";\n\t\t\tlocal b = data:sub(i+1,i+1) or \"\";\n\t\t\tif (a..b == Toolkit.Net.__crLf) then\n\t\t\t\ti = i + 1;\n\t\t\t\ttable.insert(headers, buffer);\n\t\t\t\tbuffer = \"\";\n\t\t\telse\n\t\t\t\tbuffer = buffer..a;     \n\t\t\tend\n\t\t\ti = i + 1;\n\t\tend\n\t\treturn headers;\n\tend),\n\t__readSocket = (function(socket)\n\t\tlocal err, len = 0, 1;\n\t\tlocal buffer, data = \"\", \"\";\n\t\twhile (err==0 and len>0) do\n\t\t\tdata, err = socket:read();\n\t\t\tlen = string.len(data);\n\t\t\tbuffer = buffer..data;\n\t\tend\n\t\treturn buffer, err;\n\tend),\n\t__Http = {\n\t\t__header = \"HttpRequest\",\n\t\t__version = \"1.0.3\",    \n\t\t__tcpSocket = nil,\n\t\t__timeout = 250,\n\t\t__waitBeforeReadMs = 25,\n\t\t__isConnected = false,\n\t\t__isChunked = false,\n\t\t__url = nil,\n\t\t__method = \"GET\",  \n\t\t__headers = {},\n\t\t__body = nil,\n\t\t__authorization = nil,\n\t\t-- Toolkit.Net.HttpRequest:setBasicAuthentication(username, password)\n\t\t-- Sets basic credentials for all requests.\n\t\t-- username (string) – credentials username\n\t\t-- password (string) – credentials password\n\t\tsetBasicAuthentication = (function(self, username, password)\n\t\t\tToolkit.assertArg(\"username\", username, \"string\");\n\t\t\tToolkit.assertArg(\"password\", password, \"string\");\n\t\t\t--see: http://en.wikipedia.org/wiki/Basic_access_authentication\n\t\t\tself.__authorization = Toolkit.Crypto.Base64:encode(tostring(username..\":\"..password));\n\t\tend),\n\t\t-- Toolkit.Net.HttpRequest:setBasicAuthenticationEncoded(base64String)\n\t\t-- Sets basic credentials already encoded. Avoid direct exposure for information.\n\t\t-- base64String (string)\t- username and password encoded with base64\n\t\tsetBasicAuthenticationEncoded = (function(self, base64String)\n\t\t\tToolkit.assertArg(\"base64String\", base64String, \"string\");\n\t\t\tself.__authorization = base64String;\n\t\tend),\n\t\t-- Toolkit.Net.HttpRequest:setWaitBeforeReadMs(ms)\n\t\t-- Sets ms\n\t\t-- ms (integer) – timeout value in milliseconds\n\t\tsetWaitBeforeReadMs = (function(self, ms)\n\t\t\tToolkit.assertArg(\"ms\", ms, \"integer\");\n\t\t\tself.__waitBeforeReadMs = ms;\n\t\t\tToolkit.Net.__trace(\"%s.%s::setWaitBeforeReadMs > set to %d ms\", \n\t\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, ms);\n\t\tend),\n\t\t-- Toolkit.Net.HttpRequest.getWaitBeforeReadMs()\n\t\t-- Returns the value in milliseconds\n\t\tgetWaitBeforeReadMs = (function(self)\n\t\t\treturn self.__waitBeforeReadMs;\n\t\tend),\n\t\t-- Toolkit.Net.HttpRequest.setReadTimeout(ms)\n\t\t-- Sets timeout\n\t\t-- ms (integer) – timeout value in milliseconds\n\t\tsetReadTimeout = (function(self, ms)\n\t\t\tToolkit.assertArg(\"ms\", ms, \"number\");\n\t\t\tself.__timeout = ms;\n\t\t\tToolkit.Net.__trace(\"%s.%s::setReadTimeout > Timeout set to %d ms\", \n\t\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, ms);\n\t\tend),\n\t\t-- Toolkit.Net.HttpRequest.getReadTimeout()\n\t\t-- Returns the timeout value in milliseconds\n\t\tgetReadTimeout = (function(self)\n\t\t\treturn self.__timeout;\n\t\tend),\n\t\t-- Toolkit.Net.HttpRequest:disconnect()\n\t\t-- Disconnect the socket used by httpRequest\n\t\tdisconnect = (function(self)\n\t\t\tself.__tcpSocket:disconnect();\n\t\t\tself.__isConnected = false;\n\t\t\tToolkit.Net.__trace(\"%s.%s::disconnect > Connected: %s\", \n\t\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, tostring(self.__isConnected));\n\t\tend),\n\t\t-- Toolkit.Net.HttpRequest:request(method, uri, headers, body)\n\t\t-- method (string)\t- method used for the request\n\t\t-- uri (string)\t\t- uri used for the request\n\t\t-- headers (table)\t- headers used for the request (option)\n\t\t-- body (string)\t- data sent with the request (option)\n\t\trequest = (function(self, method, uri, headers, body)\n\t\t\t-- validation\n\t\t\tToolkit.assertArg(\"method\", method, \"string\");\n\t\t\tassert(method==\"GET\" or method==\"POST\" or method==\"PUT\" or method==\"DELETE\");\n\t\t\tassert(uri~=nil or uri==\"\");\n\t\t\tself.__isChunked = false;\n\t\t\tself.__tcpSocket:setReadTimeout(self.__timeout);\n\t\t\tself.__url = uri;\n\t\t\tself.__method = method;\n\t\t\tself.__headers = headers or {};\n\t\t\tself.__body = body or nil;\n\n\t\t\t--local r = self.__method..\" http://\"..Toolkit.Net.__host..self.__url..\" HTTP/1.1\";\n\t\t\t--patch 18/12/2013\n\t\t\tlocal r = self.__method..\" \"..self.__url..\" HTTP/1.1\";\n\t\t\tToolkit.Net.__trace(\"%s.%s::request > %s with method %s\", \n\t\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, self.__url, self.__method);\n\t\t\tlocal p = \"\";\n\t\t\tif (Toolkit.Net.__port~=nil) then\n\t\t\t\tp = \":\"..tostring(Toolkit.Net.__port);\n\t\t\tend\n\t\t\tlocal h = \"Host: \"..Toolkit.Net.__host .. p;\n\t\t\t-- write to socket headers method a host!\n\t\t\tToolkit.Net.__writeHeader(self.__tcpSocket, r);\n\t\t\tToolkit.Net.__writeHeader(self.__tcpSocket, h);\n\t\t\t-- add headers if needed\n\n\t\t\tfor i = 1, #self.__headers do\n\t\t\t\tToolkit.Net.__writeHeader(self.__tcpSocket, self.__headers[i]);\n\t\t\tend\n\t\t\tif (self.__authorization~=nil) then\n\t\t\t\tToolkit.Net.__writeHeader(self.__tcpSocket, \"Authorization: Basic \"..self.__authorization);\n\t\t\tend\n\t\t\t-- add data in body if needed\n\t\t\tif (self.__body~=nil) then\n\t\t\t\tToolkit.Net.__writeHeader(self.__tcpSocket, \"Content-Length: \"..string.len(self.__body));\n\t\t\t\tToolkit.Net.__trace(\"%s.%s::request > Body length is %d\", \n\t\t\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, string.len(self.__body));\n\t\t\tend\n\t\t\tself.__tcpSocket:write(Toolkit.Net.__crLf..Toolkit.Net.__crLf);\n\t\t\t-- write body\n\t\t\tif (self.__body~=nil) then\n\t\t\t\tself.__tcpSocket:write(self.__body);\n\t\t\tend\n\t\t\t-- sleep to help process\n\t\t\tfibaro:sleep(self.__waitBeforeReadMs);\n\t\t\t-- wait socket reponse\n\t\t\tlocal result, err = Toolkit.Net.__readSocket(self.__tcpSocket);\n\t\t\tToolkit.Net.__trace(\"%s.%s::receive > Length of result: %d\", \n\t\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, string.len(result));\n\t\t\t-- parse data\n\t\t\tlocal response, status;\n\t\t\tlocal cookie = \"hello\";\n\t\t\tif (string.len(result)>0) then\n\t\t\t\tlocal _flag = string.find(result, Toolkit.Net.__crLf..Toolkit.Net.__crLf);\n\t\t\t\tlocal _rawHeader = string.sub(result, 1, _flag + 2);\n\t\t\t\tif (string.len(_rawHeader)) then\n\t\t\t\t\tstatus = string.sub(_rawHeader, 10, 13);\n\t\t\t\t\tToolkit.Net.__trace(\"%s.%s::receive > Status %s\", Toolkit.Net.__header, \n\t\t\t\t\tToolkit.Net.__Http.__header, status);\n\t\t\t\t\tToolkit.Net.__trace(\"%s.%s::receive > Length of headers reponse %d\", Toolkit.Net.__header, \n\t\t\t\t\tToolkit.Net.__Http.__header, string.len(_rawHeader));\n\t\t\t\t\t__headers = Toolkit.Net.__readHeader(_rawHeader);\n\t\t\t\t\tfor k, v in pairs(__headers) do\n\t\t\t\t\t\t--Toolkit.Net.__trace(\"raw #\"..k..\":\"..v)\n\t\t\t\t\t\tif (string.find(string.lower( v or \"\"), \"chunked\")) then\n\t\t\t\t\t\t\tself.__isChunked = true;\n\t\t\t\t\t\t\tToolkit.Net.__trace(\"%s.%s::receive > Transfer-Encoding: chunked\", \n\t\t\t\t\t\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, string.len(result));\n\t\t\t\t\t\t\t-- Modification pour récupérer le cookie.\n\t\t\t\t\t\t\t-- Ofwood Jan 2015\n\t\t\t\t\t\telseif (string.find(string.lower( v or \"\"), \"cookie\")) then\t\t\t\t\n\t\t\t\t\t\t\tcookie = string.sub(v, 12)\n\t\t\t\t\t\t\tToolkit.Net.__trace(\"%s.%s::receive > Cookie: %s\", \n\t\t\t\t\t\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, cookie);                \n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tlocal _rBody = string.sub(result, _flag + 4);\n\t\t\t\t--Toolkit.Net.__trace(\"Length of body reponse: \" .. string.len(_rBody));\n\t\t\t\tif (self.__isChunked) then\n\t\t\t\t\tresponse = Toolkit.Net.__decodeChunks(_rBody);\n\t\t\t\t\terr = 0;\n\t\t\t\telse\n\t\t\t\t\tresponse = _rBody;\n\t\t\t\t\terr = 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- return budy response\n\t\t\treturn response, status, err, cookie;\n\t\tend),\n\t\t-- Toolkit.Net.HttpRequest.version()\n\t\t-- Return the version\n\t\tversion = (function()\n\t\t\treturn Toolkit.Net.__Http.__version;\n\t\tend),\n\t\t-- Toolkit.Net.HttpRequest:dispose()\n\t\t-- Try to free memory and resources \n\t\tdispose = (function(self)      \n\t\t\tif (self.__isConnected) then\n\t\t\t\tself.__tcpSocket:disconnect();\n\t\t\tend\n\t\t\tself.__tcpSocket = nil;\n\t\t\tself.__url = nil;\n\t\t\tself.__headers = nil;\n\t\t\tself.__body = nil;\n\t\t\tself.__method = nil;\n\t\t\tif pcall(function () assert(self.__tcpSocket~=Net.FTcpSocket) end) then\n\t\t\tToolkit.Net.__trace(\"%s.%s::dispose > Successfully disposed\", \n\t\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header);\n\t\tend\n\t\t-- make sure all free-able memory is freed\n\t\tcollectgarbage(\"collect\");\n\t\tToolkit.Net.__trace(\"%s.%s::dispose > Total memory in use by Lua: %.2f Kbytes\", \n\t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, collectgarbage(\"count\"));\n\tend)\n},\n-- Toolkit.Net.isTraceEnabled\n-- true for activate trace in HC2 debug window\nisTraceEnabled = false,\n-- Toolkit.Net.HttpRequest(host, port)\n-- Give object instance for make http request\n-- host (string)\t- host\n-- port (intager)\t- port\n-- Return HttpRequest object\nHttpRequest = (function(host, port)\n\tassert(host~=Toolkit.Net, \"Cannot call HttpRequest like that!\");\n\tassert(host~=nil, \"host invalid input\");\n\tassert(port==nil or tonumber(port), \"port invalid input\");\n\t-- make sure all free-able memory is freed to help process\n\tcollectgarbage(\"collect\");\n\tToolkit.Net.__host = host;\n\tToolkit.Net.__port = port;\n\tlocal _c = Toolkit.Net.__Http;\n\t_c.__tcpSocket = Net.FTcpSocket(host, port);\n\t_c.__isConnected = true;\n\tToolkit.Net.__trace(\"%s.%s > Total memory in use by Lua: %.2f Kbytes\", \n\tToolkit.Net.__header, Toolkit.Net.__Http.__header, collectgarbage(\"count\"));\n\tToolkit.Net.__trace(\"%s.%s > Create Session on port: %d, host: %s\", \n\tToolkit.Net.__header, Toolkit.Net.__Http.__header, port, host);\n\treturn _c;\nend),\n-- Toolkit.Net.version()\nversion = (function()\n\treturn Toolkit.Net.__version;\nend)\n};\n\nToolkit:traceEx(\"red\", Toolkit.Net.__header..\" loaded in memory...\");\n-- benchmark code\nif (Toolkit.Debug) then Toolkit.Debug:benchmark(Toolkit.Net.__header..\" lib\", \"elapsed time: %.3f cpu secs\\n\", \"fragment\", true); end;\nend;\n\n\nfunction deep_print(tbl)\n\tfor i, v in pairs(tbl) do\n\t\tif type(v) == \"table\" then\n\t\t\tdeep_print(v)\n\t\telse\n\t\t\tprint(i, v)\n\t\tend\n\tend\nend\n\nfunction do_http_request( args )\n\t--http.request(url [, body])\n\t--http.request{\n\t--  url = string,\n\t--  [sink = LTN12 sink,]\n\t--  [method = string,]\n\t--  [headers = header-table,]\n\t--  [source = LTN12 source],\n\t--  [step = LTN12 pump step,]\n\t--  [proxy = string,]\n\t--  [redirect = boolean,]\n\t--  [create = function]\n\t--}\n\t--\n\t--\n\tlocal resp, r = {}, {}\n\tlocal headers = args.headers;\n\tlocal req_body = args.source;\n\tlocal retry_count = 1;\n\tif args.retry then\n\t\tif args.retry == true then\n\t\t\tretry_count = 3\n\t\tend\n\tend\n\tif args.endpoint then\n\t\tlocal params = \"\"\n\t\t--if args.method == \"POST\" and headers == nil then\n\t\theaders = {\n\t\t\t\"Content-Type: application/x-www-form-urlencoded\",\n\t\t};\n\t\tif sid ~= nil then\n\t\t\theaders[2]=\"Cookie: stay_login=0; id=\" .. sid ;\n\t\tend\n\t\t--end\n\n\t\tif args.method == nil or args.method == \"GET\" then\n\t\t\tif args.params then\n\t\t\t\tfor i, v in pairs(args.params) do\n\t\t\t\t\tparams = params .. i .. \"=\" .. v .. \"&\"\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tparams = string.sub(params, 1, -2)\n\t\tlocal url = \"\"\n\t\t-- if params then url = args.endpoint .. \"?\" .. args.source else url = args.endpoint end\n\t\turl = args.endpoint .. \"?\" .. args.source\n\t\tif debug == true then\n\t\t\tfibaro:debug(\"url = \" .. url)\n\t\t\tfibaro:debug(\"body = \" .. req_body)\n\t\tend\n\n\t\tlocal response, status, errorCode, cookie\n\n\t\tfor loop=1,retry_count do\n\t\t\tlocal httpClient = Toolkit.Net.HttpRequest(ip, port);\n\t\t\thttpClient:setReadTimeout(commandTimeOut);\n\n\t\t\t-- httpClient:request avec injection de X-Context et du Cookie dans les headers\t\n\t\t\tresponse, status, errorCode, cookie = httpClient:request(args.method, url, headers, args.source);\n\n\t\t\t-- disconnect socket and release memory...\n\t\t\thttpClient:disconnect();\n\t\t\thttpClient:dispose();\n\n\t\t\tif (response == nil or response == '') and retry_count > 1 then\n\t\t\t\tfibaro:debug(\"Failed, let's retry \" .. loop ..\"/\" .. retry_count)\n\t\t\t\tfibaro:sleep(250)\n\t\t\telse\n\t\t\t\tif (debug == true) then\n\t\t\t\t\tfibaro:debug(\"Returning songs, string length = \" .. string.len(response))\n\t\t\t\tend\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\t--client, code, headers, status = http.request{url=url, sink=ltn12.sink.table(resp),\n\t\t--                                           method=args.method or \"GET\", headers=headers, source=args.source,\n\t\t--                                          step=args.step, proxy=args.proxy, redirect=args.redirect, create=args.create }\n\t\tr['code'], r['status'], r['response'] = errorCode, status, response \n\telse\n\t\terror(\"endpoint is missing\")\n\tend\n\treturn r\nend\n\nfunction string:split(delimiter)\n\tlocal result = { }\n\tlocal from = 1\n\tlocal delim_from, delim_to = string.find( self, delimiter, from )\n\twhile delim_from do\n\t\ttable.insert( result, string.sub( self, from , delim_from-1 ) )\n\t\tfrom = delim_to + 1\n\t\tdelim_from, delim_to = string.find( self, delimiter, from )\n\tend\n\ttable.insert( result, string.sub( self, from ) )\n\treturn result\nend\n\nfunction check_success(response_data)\n\tif (string.find(response_data['response'],'\"success\":true')) then\n\t\treturn true;\n\tend\n\treturn false\nend\n-- creates string source\nfunction source_string(s)\n\tif s then\n\t\tlocal i = 1\n\t\treturn function()\n\t\t\tlocal chunk = string.sub(s, i, i+2048-1)\n\t\t\ti = i + 2048\n\t\t\tif chunk ~= \"\" then return chunk\n\t\t\telse return nil end\n\t\tend\n\telse return nil end\nend\n\nfunction login()\n\tlocal endpoint=\"/webapi/auth.cgi\"\n\tlocal req_body= \"api=SYNO.API.Auth&version=2&method=login&account=\" .. user .. \"&passwd=\" .. password .. session_url..\"&format=cookie\"\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", size=#req_body, source=req_body}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"Cannot login to \" .. base_url .. \"with user=\" .. user .. \" and password=\" .. password)\n\t\treturn nil\n\tend\n\n\tlocal sid = nil;\n\tif (string.find(response['response'],'\"data\":')) then\n\t\tsid = string.match(response['response'], '.*sid\":\"(.*)\"}.*');\n\tend\n\n\tif (check_success(response) == false) then\n\t\tfibaro:debug(\"Cannot authentificate on \" .. base_url .. \"with user=\" .. user .. \" and password=\" .. password .. \"\");\n\tend\n\n\treturn sid\nend\n\nfunction logout()\n\tlocal endpoint=\"/webapi/auth.cgi\"\n\tlocal req_body= \"api=SYNO.API.Auth&version=1&method=logout\".. session_url\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"logout: Cannot communicate with \" .. base_url )\n\t\treturn false\n\tend\n\n\treturn check_success(response)\nend\n\nfunction load_playlist(args)\n\t--raw dump : api=SYNO.AudioStation.RemotePlayer&method=updateplaylist&library=shared&id=00A0DE8F41F8&offset=0&limit=291&play=true&version=2&containers_json=%5B%7B%22type%22%3A%22playlist%22%2C%22id%22%3A%22playlist_shared_smart%2F1%22%7D%5D\n\tplaylist = nil\n\tif args then\n\t\tif args.playlist then\n\t\t\tplaylist=args.playlist\n\t\tend\n\tend\n\tif playlist == nil then\n\t\tfibaro:debug(\"load_playlist: No playlist provided\")\n\t\treturn false\n\telse\n\t\tfibaro:debug(\"load_playlist: Loading \" .. playlist)\n\tend\n\n\tlocal endpoint=\"/webapi/AudioStation/remote_player.cgi\"\n\tlocal req_body=\"api=SYNO.AudioStation.RemotePlayer&method=updateplaylist&library=shared&id=\" .. player_id .. \"&offset=0&limit=8192&play=true&version=2&containers_json=%5B%7B%22type%22%3A%22playlist%22%2C%22id%22%3A%22playlist_shared_smart%2F\"..playlist ..\"%22%7D%5D\"\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body, retry=true}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"load_playlist: Cannot communicate with \" .. base_url )\n\t\treturn false\n\tend\n\n\treturn check_success(response)\nend\n\nfunction get_random_songs(args)\n\tquantity=100\n\tif args then\n\t\tif args.quantity then\n\t\t\tquantity=args.quantity\n\t\tend\n\tend\n\tlocal songs = nil\n\tlocal endpoint=\"/webapi/AudioStation/song.cgi\"\n\t-- raw dump :   limit=100&method=list&library=shared&api=SYNO.AudioStation.Song&additional=song_tag%2Csong_audio%2Csong_rating&sort_by=random&version=2\n\tlocal req_body=\"limit=\".. quantity ..\"&method=list&library=shared&api=SYNO.AudioStation.Song&additional=song_tag,song_audio,song_rating&sort_by=random&version=2\"\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body, retry=true}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"add_random_songs: Cannot communicate with \" .. base_url )\n\t\treturn songs\n\tend\n\n\tlocal num_songs = 0\n\n\tfor music_id in string.gmatch(response['response'], '\"id\":\"(music_%d+)\"') do\n\t\tif num_songs == 0 then\n\t\t\tsongs = music_id\n\t\telse\n\t\t\tsongs = songs ..\"%2C\" .. music_id\n\t\tend\n\t\tnum_songs = num_songs + 1\n\tend\n\tfibaro:debug(\"Got \" .. num_songs .. \" songs from the library\")\n\treturn songs\nend\n\nfunction get_status()\n\tif player_id == nil then\n\t\treturn nil\n\tend\n\tlocal endpoint=\"/webapi/AudioStation/remote_player_status.cgi\"\n\tlocal req_body=\"api=SYNO.AudioStation.RemotePlayerStatus&method=getstatus&id=\" .. player_id ..\"&additional=song_tag%2Csong_audio%2Csubplayer_volume&version=1\"\n\t--raw dump https://192.168.1.2:5001/webapi/AudioStation/remote_player_status.cgi?_dc=1441828916457&SynoToken=9vE1YlwNO7s0g&api=SYNO.AudioStation.RemotePlayerStatus&method=getstatus&id=00A0DE8F41F8&additional=song_tag%2Csong_audio%2Csubplayer_volume&version=1\n\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"get_status: Cannot communicate with \" .. base_url )\n\t\treturn nil\n\tend\n\tif check_success(response) == false then\n\t\treturn nil;\n\tend\n\n\treturn json.decode(response['response'])\nend\n\nfunction get_playlist_size()\n\tlocal status = get_status()\n\tif status then\n\t\treturn status.data[\"playlist_total\"]\n\tend\n\treturn -1\nend\n\n\nfunction extract_current_volume(status)\n\tif status then\n\t\treturn status.data[\"volume\"]\n\tend\n\treturn 0\nend\n\nfunction extract_current_title(status)\n\tif status then\n\t\tif type(status.data.song) ~= \"userdata\" then\n\t\t\ttitle = status.data.song[\"title\"]\n\t\t\tif status.data.song.additional.song_tag[\"artist\"] then\n\t\t\t\ttitle = title .. \" - \" .. status.data.song.additional.song_tag[\"artist\"]\n\t\t\tend\n\t\t\treturn title\n\t\tend\n\tend\n\treturn \"\"\nend\n\n\nfunction get_current_volume()\n\treturn extract_current_volume(get_status())\nend\n\nfunction delete_playlist()\n\tlocal playlist_size = get_playlist_size()\n\tfibaro:debug(\"delete_playlist: About to delete \" .. playlist_size .. \" songs from playlist\")\n\tlocal endpoint=\"/webapi/AudioStation/remote_player.cgi\"\n\t-- raw dump api=SYNO.AudioStation.RemotePlayer&method=updateplaylist&library=shared&id=00A0DE8F41F8&offset=0&limit=6&play=false&version=2&updated_index=-2\n\tlocal req_body=\"api=SYNO.AudioStation.RemotePlayer&method=updateplaylist&library=shared&id=\".. player_id ..\"&offset=0&limit=\"..playlist_size ..\"&play=false&version=2&updated_index=-2\"\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"delete_playlist: Cannot communicate with \" .. base_url )\n\t\treturn false\n\tend\n\n\treturn check_success(response)\nend\n\nfunction add_songs_to_playlist( args )\n\tlocal playlist_name = \"shared\"\n\tif args.playlist ~= nil then\n\t\tplaylist_name = args.playlist\n\tend\n\tfibaro:debug(\"Adding songs to \" .. playlist_name ..\" playlist\")\n\tlocal endpoint=\"/webapi/AudioStation/remote_player.cgi\"\n\t-- raw dump : api=SYNO.AudioStation.RemotePlayer&method=updateplaylist&library=shared&id=00A0DE8F41F8&offset=0&limit=0&play=true&version=2&songs=music_92991%2Cmusic_101957%2Cmusic_99850%2Cmusic_100946%2Cmusic_94461%2Cmusic_90734%2Cmusic_99190%2Cmusic_93974%2Cmusic_89252%2Cmusic_101838%2Cmusic_96467%2Cmusic_90146%2Cmusic_99114%2Cmusic_105745%2Cmusic_106421%2Cmusic_107979%2Cmusic_101295%2Cmusic_109016%2Cmusic_93710%2Cmusic_106160%2Cmusic_99439%2Cmusic_96890%2Cmusic_104606%2Cmusic_98656%2Cmusic_89201%2Cmusic_95571%2Cmusic_90466%2Cmusic_91366%2Cmusic_103793%2Cmusic_96785%2Cmusic_100434%2Cmusic_103773%2Cmusic_107857%2Cmusic_107255%2Cmusic_91556%2Cmusic_111901%2Cmusic_94906%2Cmusic_98338%2Cmusic_104100%2Cmusic_88904%2Cmusic_91795%2Cmusic_94756%2Cmusic_96072%2Cmusic_105218%2Cmusic_105176%2Cmusic_105580%2Cmusic_96733%2Cmusic_97150%2Cmusic_99861%2Cmusic_97841%2Cmusic_100186%2Cmusic_106705%2Cmusic_98084%2Cmusic_94850%2Cmusic_94248%2Cmusic_107514%2Cmusic_104459%2Cmusic_90621%2Cmusic_105858%2Cmusic_94969%2Cmusic_94280%2Cmusic_101434%2Cmusic_99830%2Cmusic_108921%2Cmusic_97369%2Cmusic_99210%2Cmusic_101400%2Cmusic_88990%2Cmusic_101772%2Cmusic_104251%2Cmusic_103201%2Cmusic_97200%2Cmusic_90398%2Cmusic_89702%2Cmusic_92789%2Cmusic_91109%2Cmusic_100605%2Cmusic_106710%2Cmusic_110166%2Cmusic_103803%2Cmusic_106290%2Cmusic_112508%2Cmusic_97676%2Cmusic_109301%2Cmusic_96993%2Cmusic_94053%2Cmusic_90892%2Cmusic_98786%2Cmusic_95868%2Cmusic_101137%2Cmusic_108098%2Cmusic_106492%2Cmusic_102488%2Cmusic_108661%2Cmusic_91074%2Cmusic_89510%2Cmusic_105946%2Cmusic_104231%2Cmusic_97420%2Cmusic_90727&containers_json=%5B%5D\n\tlocal req_body=\"api=SYNO.AudioStation.RemotePlayer&method=updateplaylist&library=\" .. playlist_name .. \"&id=\" .. player_id .. \"&offset=0&limit=0&play=true&version=2&songs=\".. args.songs .. \"&containers_json=%5B%5D\"\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"add_songs_to_playlist: Cannot communicate with \" .. base_url )\n\t\treturn false\n\tend\n\treturn check_success(response)\n\nend\n\nfunction get_playlist()\n\tlocal endpoint=\"/webapi/AudioStation/remote_player.cgi\"\n\t-- raw dump     api=SYNO.AudioStation.RemotePlayer&method=getplaylist&id=00A0DE8F41F8&additional=song_tag%2Csong_audio%2Csong_rating&offset=0&limit=8192&version=2\n\tlocal req_body=\"api=SYNO.AudioStation.RemotePlayer&method=getplaylist&id=\" .. player_id .. \"&additional=song_tag%2Csong_audio%2Csong_rating&offset=0&limit=8192&version=2\"\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"get_playlist: Cannot communicate with \" .. base_url )\n\t\treturn nil\n\tend\n\n\tif (check_success(response) == false) then\n\t\treturn nil\n\tend\n\treturn json.decode(response['response'])\nend\n\nfunction table.val_to_str ( v )\n  if \"string\" == type( v ) then\n    v = string.gsub( v, \"\\n\", \"\\\\n\" )\n    if string.match( string.gsub(v,\"[^'\\\"]\",\"\"), '^\"+$' ) then\n      return \"'\" .. v .. \"'\"\n    end\n    return '\"' .. string.gsub(v,'\"', '\\\\\"' ) .. '\"'\n  else\n    return \"table\" == type( v ) and table.tostring( v ) or\n      tostring( v )\n  end\nend\n \nfunction table.key_to_str ( k )\n  if \"string\" == type( k ) and string.match( k, \"^[_%a][_%a%d]*$\" ) then\n    return k\n  else\n    return \"[\" .. table.val_to_str( k ) .. \"]\"\n  end\nend\n \nfunction table.tostring( tbl )\n  local result, done = {}, {}\n  for k, v in ipairs( tbl ) do\n    table.insert( result, table.val_to_str( v ) )\n    done[ k ] = true\n  end\n  for k, v in pairs( tbl ) do\n    if not done[ k ] then\n      table.insert( result,\n        table.key_to_str( k ) .. \"=\" .. table.val_to_str( v ) )\n    end\n  end\n  return \"{\" .. table.concat( result, \",\" ) .. \"}\"\nend\n\nfunction find_player_id(lookup_name)\n\tlocal endpoint=\"/webapi/AudioStation/remote_player.cgi\"\n\tlocal req_body=\"api=SYNO.AudioStation.RemotePlayer&method=list&version=2\"\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"stop: Cannot communicate with \" .. base_url )\n\t\treturn nil\n\tend\n\n\tplayers = json.decode(response['response'])\n\tif players.data then\n\t\tif players.data.players then\n\t\t\tfor i = 1, #players.data.players do\n\t\t\t\tplayer = players.data.players[i]\n\t\t\t\tfibaro:debug(\"Found player '\".. player.name .. \"', id = \" .. player.id)\n\t\t\t\tif string.lower(player.name) == string.lower(lookup_name) then\n\t\t\t\t\treturn player.id\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\treturn nil\nend\n\nfunction simple_control(action)\n\tlocal endpoint = \"/webapi/AudioStation/remote_player.cgi\"\n\tlocal req_body = \"api=SYNO.AudioStation.RemotePlayer&method=control&id=\" .. player_id .. \"&version=2&action=\" .. action\n\t-- raw dump : api=SYNO.AudioStation.RemotePlayer&method=control&id=00A0DE8F41F8&version=2&action=next\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"simple_control(\" .. action .. \"): Cannot communicate with \" .. base_url )\n\t\treturn false\n\tend\n\n\treturn check_success(response)\nend\n\nfunction next_song()\n\tfibaro:debug(\"Getting next song for player \" .. player_name )\n\treturn simple_control(\"next\")\nend\n\nfunction previous_song()\n\tfibaro:debug(\"Getting previous song for player \" .. player_name )\n\treturn simple_control(\"prev\")\nend\n\nfunction pause()\n\tfibaro:debug(\"Pausing song for player \" .. player_name )\n\treturn simple_control(\"pause\")\nend\n\nfunction stop()\n\tfibaro:debug(\"Stopping player \" .. player_name )\n\treturn simple_control(\"stop\")\nend\n\nfunction play(position)\n\tfibaro:debug(\"Starting player \" .. player_name )\n\tif (position ~= nil) then\n\t\treturn simple_control(\"play&value=\" .. position)\n\telse\n\t\treturn simple_control(\"play\")\n\tend\nend\n\nfunction set_volume( volume )\n\tif volume < 0 then\n\t\tvolume = 0\n\tend\n\n\tif volume > 100 then\n\t\tvolume = 100\n\tend\n\n\tfibaro:debug(\"Adjusting volume of \" .. player_name .. \" to \" .. volume .. \"%\")\n\tlocal endpoint = \"/webapi/AudioStation/remote_player.cgi\"\n\tlocal req_body = \"api=SYNO.AudioStation.RemotePlayer&method=control&id=\" .. player_id .. \"&version=2&action=set_volume&value=\" .. volume\n\t--raw dump : api=SYNO.AudioStation.RemotePlayer&method=control&id=00A0DE8F41F8&version=2&action=set_volume&value=36\n\tlocal response = do_http_request{endpoint=endpoint, method=\"GET\", source=req_body}\n\tif (tonumber(response['status']) ~= 200) then\n\t\tfibaro:debug(\"set_volume: Cannot communicate with \" .. base_url )\n\t\treturn false\n\tend\n\n\treturn check_success(response)\nend\n\nlocal clock = os.clock\nfunction sleep(n)  -- seconds\n\tlocal t0 = clock()\n\twhile clock() - t0 <= n do end\nend\n\nfunction stream_random_songs(args)\n\tsongs = get_random_songs{quantity=args.quantity}\n\tif (songs == nil) then\n\t\tfibaro:debug(\"Cannot add random songs !\")\n\t\treturn\n\tend\n\n\tif (delete_playlist() == false) then\n\t\tfibaro:debug(\"Cannot delete playlist\")\n\t\treturn\n\tend\n\n\tif (add_songs_to_playlist{songs=songs} == false) then\n\t\tfibaro:debug(\"Cannot add songs to playlist\")\n\t\treturn\n\tend\n\n\tif (stop() == false) then\n\t\tfibaro:debug(\"Cannot stop music !\")\n\t\treturn\n\tend\n\n\tif (play(0) == false) then\n\t\tfibaro:debug(\"Cannot play music !\")\n\t\treturn\n\tend\nend\n\nfunction stream_playlist(args)\n\tif load_playlist(args) == false then\n\t\tfibaro:debug(\"Cannot load playlist !\")\n\t\treturn\n\tend\n\n\tif (stop() == false) then\n\t\tfibaro:debug(\"Cannot stop music !\")\n\t\treturn\n\tend\n\n\tif (play(0) == false) then\n\t\tfibaro:debug(\"Cannot play music !\")\n\t\treturn\n\tend\nend\n\nfunction connect()\n\tsid=login()\n\tif (sid == nil) then\n\t\tfibaro:debug(\"Cannot find a valid SID in the response\");\n\t\treturn false\n\tend\n\n\tfibaro:debug(\"### Connected to DSAudio with user \" .. user .. \" ! ###\");\n\n\tplayer_id = find_player_id(player_name)\n\tif player_id == nil then\n\t\tfibaro:debug(\"Cannot find any player matching '\".. player_name .. \"', Exiting !\")\n\t\treturn false\n\tend\n\n\tfibaro:debug(\"Using player \" .. player_name)\n\treturn true\nend\n\n\nfibaro:debug(\"<< DSAudio plugin version \" .. version .. \"-\" .. release .. \" by Erwan Velu >>\")\nfibaro:debug(\"<< Download the latest version at https://github.com/ErwanAliasr1/hc2-addons >>\")\nfibaro:debug(\"<< Enjoy ! >>\")\nfibaro:setGlobal(\"DSAudio_Control\", \"nop\")\nif (fibaro:getGlobalValue(\"DSAudio_Control\") ~= \"nop\") then\n\tfibaro:debug(\"Please create a DSAudio_Control global variable, Exiting !\")\n\treturn\nend\nif connect() == true then\n\tfibaro:debug(\"Entering main loop\")\n\tlocal current_volume = 0\n\twhile true do\n\t\tlocal control = fibaro:getGlobalValue(\"DSAudio_Control\")\n\t\tif control == \"play\" then\n\t\t\tfibaro:debug('Received Play request')\n\t\t\tfibaro:setGlobal(\"DSAudio_Control\", \"nop\")\n\t\t\tplay()\n\t\telse if control == \"stop\" then\n\t\t\tfibaro:debug('Received Stop request')\n\t\t\tfibaro:setGlobal(\"DSAudio_Control\", \"nop\")\n\t\t\tstop()\n\t\telse if control == \"pause\" then\n\t\t\tfibaro:debug('Received Pause request')\n\t\t\tfibaro:setGlobal(\"DSAudio_Control\", \"pause\")\n\t\t\tpause()\n\t\telse if control == \"previous\" then\n\t\t\tfibaro:debug('Received Previous request')\n\t\t\tfibaro:setGlobal(\"DSAudio_Control\", \"nop\")\n\t\t\tprevious_song()\n\t\telse if control == \"next\" then\n\t\t\tfibaro:debug('Received Next request')\n\t\t\tfibaro:setGlobal(\"DSAudio_Control\", \"nop\")\n\t\t\tnext_song()\n\t\telse if string.match(control, \"volume_%d+\") then\n\t\t\tfibaro:debug('Received Volume request')\n\t\t\tfibaro:setGlobal(\"DSAudio_Control\", \"nop\")\n\t\t\tcurrent_volume = tonumber(string.match(control, \"volume_(%d+)\"))\n\t\t\tset_volume(current_volume)\n\t\telse if control == \"random\" then\n\t\t\tfibaro:debug('Received Random request')\n\t\t\tfibaro:setGlobal(\"DSAudio_Control\", \"nop\")\n\t\t\tstream_random_songs{quantity=75\t}\n\t\telse if string.match(control,\"playlist_\") then\n\t\t\tplaylist = string.match(control,'playlist_(.*)')\n\t\t\tfibaro:debug('Received playlist request (' .. playlist .. ')')\n\t\t\tfibaro:setGlobal(\"DSAudio_Control\", \"nop\")\n\t\t\tstream_playlist{playlist=playlist}\n\t\tend\n\t\tend\n\t\tend\n\t\tend\n\t\tend\n\t\tend\n\t\tend\n\t\tend\n\t\t-- Did we got another action since ?\n\t\t-- If so, let's handle it right now\n\t\tcontrol = fibaro:getGlobalValue(\"DSAudio_Control\")\n\t\tif (control == \"nop\") then\n\t\t\t-- Nothing required, don't flood NAS with get_status()\n\t\t\tfibaro:sleep(250)\n\t\t\tcurrent_status = get_status()\n\t\t\tif current_status == nil then\n\t\t\t\tfibaro:debug(\"Lost link with DSAudio, trying to reconnect\")\n\t\t\t\tconnect()\n\t\t\telse\n\t\t\t\tfibaro:call(fibaro:getSelfId(), \"setProperty\", \"ui.label_3_4.value\", extract_current_title(current_status))\n\t\t\t\tnew_volume = extract_current_volume(current_status)\n\t\t\t\tif new_volume >= 0 then\n\t\t\t\t\tif new_volume ~= current_volume then\n\t\t\t\t\t\tfibaro:call(fibaro:getSelfId(), \"setProperty\", \"ui.slider_1_1.value\", new_volume)\n\t\t\t\t\t\tcurrent_volume = new_volume\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\t\n\t-- If you put that code in a slider, just use the following\n\t--set_volume(_sliderValue_)\n\n\t-- If you put that code in a set of buttons, just use the following:\n\t-- stop()\n\t-- previous_song()\n\t-- next_song()\n\t-- pause()\n\t-- play()\n\n\t-- set_volume(default_volume)\n\t-- stream_random_songs{quantity=75}\nend\n\nif (logout() == false) then\n\tfibaro:debug(\"Cannot logout properly\")\nelse\n\tfibaro:debug(\"No more connected with DSAudio\")\nend","ui.label_3_0.value":"Look at Them","ui.label_3_4.value":"","ui.slider_1_0.value":35,"ui.slider_1_1.value":0,"visible":"true","rows":[{"type":"button","elements":[{"id":1,"lua":true,"waitForResponse":false,"caption":"Random","name":"Random","empty":false,"msg":"fibaro:setGlobal('DSAudio_Control', 'random')\n","buttonIcon":0,"favourite":false,"main":true}]},{"type":"slider","elements":[{"id":2,"lua":true,"waitForResponse":false,"caption":"Volume","name":"slider_1_1","msg":"fibaro:setGlobal('DSAudio_Control', 'volume_' .. _sliderValue_)\n","buttonIcon":0,"value":0,"favourite":false,"main":true}]},{"type":"button","elements":[{"id":3,"lua":true,"waitForResponse":false,"caption":"Pre","name":"Previous","empty":false,"msg":"fibaro:setGlobal('DSAudio_Control', 'previous')","buttonIcon":0,"favourite":false,"main":false},{"id":4,"lua":true,"waitForResponse":false,"caption":"#","name":"Stop","empty":false,"msg":"fibaro:setGlobal('DSAudio_Control', 'stop')","buttonIcon":0,"favourite":false,"main":false},{"id":5,"lua":true,"waitForResponse":false,"caption":"II","name":"Pause","empty":false,"msg":"fibaro:setGlobal('DSAudio_Control', 'pause')","buttonIcon":0,"favourite":false,"main":false},{"id":6,"lua":true,"waitForResponse":false,"caption":"&gt","name":"Play","empty":false,"msg":"fibaro:setGlobal('DSAudio_Control', 'play')","buttonIcon":0,"favourite":false,"main":false},{"id":7,"lua":true,"waitForResponse":false,"caption":"Nxt","name":"Next","empty":false,"msg":"fibaro:setGlobal('DSAudio_Control', 'next')","buttonIcon":0,"favourite":false,"main":false}]},{"type":"label","elements":[{"id":8,"lua":false,"waitForResponse":false,"caption":"","name":"label_3_4","favourite":false,"main":true}]},{"type":"button","elements":[{"id":9,"lua":true,"waitForResponse":false,"caption":"playlist","name":"Button31","empty":false,"msg":"fibaro:setGlobal('DSAudio_Control', 'playlist_nameofplaylist')","buttonIcon":0,"favourite":false,"main":false}]}]},"actions":{"pressButton":1,"setSlider":2,"setProperty":2}}